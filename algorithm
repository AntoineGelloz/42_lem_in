Algorithm: Modified Edmonds-Karp with BFS searching for the paths minimizing the lines of output

function main(options):
	parse the arguments for any options
	parse the file from stdin (get ants number, rooms and tunnels)
	build the graph with an adjacency list
	if (parsing error):
		print error and exit
	initialize paths list to null
	paths = find_paths(graph)
	if (no solution is found):
		print error and exit
	print the file on stdout
	assign each ant to a path
	let the ants pass into the graph by printing one line of output for each round
	display any options for arguments

function find_paths(graph):
	initialize paths list to null
	new_path = bfs(graph)
	append new_path to paths
	reduce capacities of the new_path forward edges
	increase capacities of the new_path backward edges
	compute the initial lines of output using only this first path
	point to the first path with selected_path
	while (selected_path did not reach the end of the paths list):
		store the previous number of paths found
		new_path = bfs(graph, selected_path)
		compute the new lines of output
		if (the new output is minimized):
			update the count of lines of output
			append new_paths to paths
			reduce capacities of the new_path forward edges to 0
			increase capacities of the new_path backward edges to 2
			selected_path to first path
		else:
			discard new_path
			selected_path to next path
	return (paths)

function bfs(graph, selected_path):
	create a queue and add start_room
	create a prev[size of graph] array to keep track of previous rooms when enqueued
	while (queue is not empty):
		room = dequeue(queue)
		for each (neighbours of room NOT already enqueued):
			if (room is NOT on selected_path AND NOT end_room):
				if (neighbour is on selected_path AND NOT a start_room neighbour):
					mark neighbour as visited
					mark neighbour as already enqueued
					update prev[neighbour] = room
					select neighbour2 as the previous room of neighbour on the selected_path
					enqueue(neighbour, neighbour2)
				else if (neighbour is NOT visited):
					enqueue(room, neighbour)
			else if (room is on selected_path
					AND (edge to neighbour has a capacity of 2 AND NOT start_room
						|| edge to neighbour has a capacity of 1 AND NOT visited)):
				enqueue(room, neighbour)
	return (reconstruct_path(graph, prev))

function reconstruct_path(graph, prev):
	initialize new_paths list to null
	room = end_room
	while (room exists):
		add room to new_path list
		room = prev[room]
	if (the first room of new_path is start):
		reset all rooms visited on the new_path
		return (new_path)
	else:
		reset all rooms visited
		return (null)

function enqueue(room, neighbour):
	mark neighbour as visited
	mark neighbour as already enqueued
	update prev[neighbour] = room
	enqueue(neighbour)
